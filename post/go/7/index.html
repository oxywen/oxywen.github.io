<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Golang学习笔记-06切片"><meta name="keywords" content="笔记,go"><meta name="author" content="Oxywen"><meta name="copyright" content="Oxywen"><title>Golang学习笔记-06切片 | 不闻星河须臾</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="/pio/static/pio.css"><script src="/pio/static/l2d.js"></script><script src="/pio/static/pio.js"></script><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-6762629114964129',
  enable_page_level_ads: 'true'
});
</script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?ca2650c4c7f8c24a413550104d43d6f3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#切片的本质"><span class="toc-number">1.</span> <span class="toc-text">切片的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#切片的定义和初始化"><span class="toc-number">2.</span> <span class="toc-text">切片的定义和初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#声明语法"><span class="toc-number">2.1.</span> <span class="toc-text">声明语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#初始化"><span class="toc-number">2.2.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#切片表达式"><span class="toc-number">2.3.</span> <span class="toc-text">切片表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#简单切片表达式"><span class="toc-number">2.3.1.</span> <span class="toc-text">简单切片表达式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#完整切片表达式"><span class="toc-number">2.3.2.</span> <span class="toc-text">完整切片表达式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态定义"><span class="toc-number">2.4.</span> <span class="toc-text">动态定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#切片的访问和修改"><span class="toc-number">3.</span> <span class="toc-text">切片的访问和修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#切片的赋值拷贝"><span class="toc-number">4.</span> <span class="toc-text">切片的赋值拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#切片的长度和容量"><span class="toc-number">5.</span> <span class="toc-text">切片的长度和容量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#长度"><span class="toc-number">5.1.</span> <span class="toc-text">长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#容量"><span class="toc-number">5.2.</span> <span class="toc-text">容量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#切片的遍历"><span class="toc-number">6.</span> <span class="toc-text">切片的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#空切片"><span class="toc-number">7.</span> <span class="toc-text">空切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#切片不能直接比较"><span class="toc-number">8.</span> <span class="toc-text">切片不能直接比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#切片的添加和复制"><span class="toc-number">9.</span> <span class="toc-text">切片的添加和复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#append添加"><span class="toc-number">9.1.</span> <span class="toc-text">append添加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#切片的扩容"><span class="toc-number">9.2.</span> <span class="toc-text">切片的扩容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#copy复制"><span class="toc-number">9.3.</span> <span class="toc-text">copy复制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#切片的删除"><span class="toc-number">10.</span> <span class="toc-text">切片的删除</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://ww1.yunjiexi.club/2020/03/12/cLzMt.jpg"></div><div class="author-info__name text-center">Oxywen</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/oxywen" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">14</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">8</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">3</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://waxxh.me/" target="_blank" rel="noopener">Waxxh's Blog</a><a class="author-info-links__name text-center" href="http://www.sweetsmoe.com/" target="_blank" rel="noopener">甜小萌</a><a class="author-info-links__name text-center" href="https://www.nmoe.cn/" target="_blank" rel="noopener">花落知雨</a><a class="author-info-links__name text-center" href="https://www.yuanshuli.com/" target="_blank" rel="noopener">碧海长天</a><a class="author-info-links__name text-center" href="https://www.xujianhua.com/" target="_blank" rel="noopener">许建华博客</a><a class="author-info-links__name text-center" href="https://yanqiyu.info/" target="_blank" rel="noopener">Karuboniru's Blog</a></div></div></div><!-- 判断是否启用aplayer--><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><meting-js id="4944495601" server="netease" type="playlist" fixed="true" order="random" preload="auto" autoplay="false" loop="all" mutex="true" volume="0.7" list-olded="true" theme="#49b1f5"></meting-js><div class="pio-container" style="right:0;"><div class="pio-action"></div><canvas id="pio" width="300" height="256"></canvas></div><script type="text/javascript">var pio = new Paul_Pio({
  "mode": "static",
  "hidden": false,
  "content": {
  "welcome": ["你好，欢迎来到Oxywen的小窝，希望玩得开心","你好呀，我是Pio，傲完就娇的Pio~"],
  "referer": "欢迎你，来自%t的用户",
  },
  "model": ["/pio/models/pio/model.json"]
  })</script><div id="content-outer"><div id="top-container" style="background-image: url(https://ww2.yunjiexi.club/2019/05/01/DZvIP.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">不闻星河须臾</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">Golang学习笔记-06切片</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-08</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/go/">go</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">3k</span><span class="post-meta__separator">|</span><span>阅读时长: 10 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h3 id="切片的本质"><a href="#切片的本质" class="headerlink" title="切片的本质"></a>切片的本质</h3><p>数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性，比如不能动态添加元素。</p>
<p>Go中提供了一种灵活，功能强悍的内置类型 切片slice (“动态数组”)，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。</p>
<p>切片Slice是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装，它非常灵活，支持自动扩容。切片本身没有任何数据。它们只是对现有数组的引用。与数组相比，切片不需要设定长度，即声明时在[ ]中不用设定值。</p>
<p>slice从底层来说，其实就是一个数据结构(struct结构体)。可以看出，切片是对数组的抽象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span>&#123;</span><br><span class="line">  ptr *[]<span class="keyword">int</span>  <span class="comment">//指针，指向数组中slice指定的开始位置</span></span><br><span class="line">  <span class="built_in">len</span> <span class="keyword">int</span>  <span class="comment">//长度，随元素数量的变化而变化</span></span><br><span class="line">  <span class="built_in">cap</span> <span class="keyword">int</span>  <span class="comment">//容量，也就是slice开始位置到数组的最后位置的长度，最大长度（可扩容的）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，切片是引用类型，数组是值类型</p>
<h3 id="切片的定义和初始化"><a href="#切片的定义和初始化" class="headerlink" title="切片的定义和初始化"></a>切片的定义和初始化</h3><h4 id="声明语法"><a href="#声明语法" class="headerlink" title="声明语法"></a>声明语法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 []类型</span><br></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="keyword">string</span>              <span class="comment">//声明一个字符串切片</span></span><br><span class="line">fmt.Println(a)              <span class="comment">//输出  []</span></span><br></pre></td></tr></table></figure>

<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = []<span class="keyword">int</span>&#123;&#125;             <span class="comment">//声明一个整型切片并初始化</span></span><br><span class="line"><span class="keyword">var</span> c = []<span class="keyword">bool</span>&#123;<span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="comment">//声明一个布尔切片并初始化</span></span><br><span class="line"><span class="keyword">var</span> d = []<span class="keyword">bool</span>&#123;<span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="comment">//声明一个布尔切片并初始化</span></span><br><span class="line">fmt.Println(a)              <span class="comment">//[]</span></span><br><span class="line">fmt.Println(b)              <span class="comment">//[]</span></span><br><span class="line">fmt.Println(c)              <span class="comment">//[false true]</span></span><br><span class="line">fmt.Println(a == <span class="literal">nil</span>)       <span class="comment">//true</span></span><br><span class="line">fmt.Println(b == <span class="literal">nil</span>)       <span class="comment">//false</span></span><br><span class="line">fmt.Println(c == <span class="literal">nil</span>)       <span class="comment">//false</span></span><br><span class="line"><span class="comment">// fmt.Println(c == d)   //这样比较是错误的，切片是引用类型，不支持直接比较，只能和nil比较</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>&#125;	<span class="comment">//这是声明一个数组，并使用编译器自动推断数组的长度</span></span><br><span class="line"><span class="keyword">var</span> b = []<span class="keyword">int</span>&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>&#125;	<span class="comment">//这才是声明一个切片</span></span><br></pre></td></tr></table></figure>

<h4 id="切片表达式"><a href="#切片表达式" class="headerlink" title="切片表达式"></a>切片表达式</h4><p>切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片。它有两种变体：一种指定low和high两个索引界限值的简单的形式，另一种是除了low和high索引界限值外还指定容量的完整的形式。</p>
<h5 id="简单切片表达式"><a href="#简单切片表达式" class="headerlink" title="简单切片表达式"></a>简单切片表达式</h5><p>切片的底层就是一个数组，所以我们可以基于数组通过切片表达式得到切片。 切片表达式中的<code>low</code>和<code>high</code>表示一个索引范围（左包含，又不包含），也就是下面代码中从数组a中选出<code>1&lt;=索引值&lt;4</code>的元素组成切片s，得到的切片<code>长度=high-low</code>，容量等于得到的切片的底层数组的容量。</p>
<p>根据缺省条件可分为下面几种：</p>
<p>将arr中从下标startIndex到endIndex-1 下的元素创建为一个新的切片（左闭右开），长度为 high-low</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = arr[low:high]</span><br></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s := a[<span class="number">1</span>:<span class="number">3</span>]  <span class="comment">// s := a[low:high]</span></span><br></pre></td></tr></table></figure>

<p>缺省endIndex时将表示一直到arr的最后一个元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s :&#x3D; arr[low:]</span><br></pre></td></tr></table></figure>

<p>缺省startIndex时将表示从arr的第一个元素开始</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s :&#x3D; arr[:high]</span><br></pre></td></tr></table></figure>

<p>全部缺省，表示直接从该数组的全部元素构建</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[:]</span><br></pre></td></tr></table></figure>

<p>注意：对于数组或字符串，必须保证索引不越界</p>
<p>对切片再执行切片表达式时（切片再切片），<code>high</code>的上限边界是切片的容量<code>cap(a)</code>，而不是长度。<strong>常量索引</strong>必须是非负的，并且可以用int类型的值表示。对于数组或常量字符串，常量索引也必须在有效范围内。如果<code>low</code>和<code>high</code>两个指标都是常数，它们必须满足<code>low &lt;= high</code>。如果索引在运行时超出范围，就会发生运行时<code>panic</code>。</p>
<h5 id="完整切片表达式"><a href="#完整切片表达式" class="headerlink" title="完整切片表达式"></a>完整切片表达式</h5><p>对于数组，指向数组的指针，或切片a(注意不能是字符串)支持完整切片表达式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[low : high : max]</span><br></pre></td></tr></table></figure>

<p>上面的代码会构造与简单切片表达式<code>a[low: high]</code>相同类型、相同长度和元素的切片。另外，它会将得到的结果切片的容量设置为<code>max-low</code>。在完整切片表达式中只有第一个索引值（low）可以省略，但是冒号：不能省略，它默认为0。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">t := a[<span class="number">1</span>:<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Printf(<span class="string">"t:%v len(t):%v cap(t):%v\n"</span>, t, <span class="built_in">len</span>(t), <span class="built_in">cap</span>(t))</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t:[2 3] len(t):2 <span class="built_in">cap</span>(t):4</span><br></pre></td></tr></table></figure>

<p>完整切片表达式需要满足的条件是<code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code>，其他条件和简单切片表达式相同。</p>
<h4 id="动态定义"><a href="#动态定义" class="headerlink" title="动态定义"></a>动态定义</h4><p>上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的<code>make()</code>函数，格式如下：</p>
<p>make是内建函数，你可以在 <a href="http://docscn.studygolang.com/pkg/builtin/#make" target="_blank" rel="noopener">http://docscn.studygolang.com/pkg/builtin/#make</a> 这儿看到它，简单的说就是为slice、map和channel分配内存和初始化，返回一个引用类型的对象</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>, <span class="built_in">cap</span>) <span class="comment">//T:切片的元素类型,size:切片中元素的数量,cap:切片的容量</span></span><br></pre></td></tr></table></figure>

<p>当然，你也可以不指定cap，这是cap默认等于len。返回的切片的数组元素全部为零值</p>
<h3 id="切片的访问和修改"><a href="#切片的访问和修改" class="headerlink" title="切片的访问和修改"></a>切片的访问和修改</h3><p>同数组一样，切片也可以通过下标来访问对应的元素，并修改它。</p>
<p>slice没有自己的任何数据。它只是底层数组的一个表示。对slice所做的任何修改都将反映在底层数组中。</p>
<p>也就是说，如果一个切片是根据一个数组创建的，那么如果我们对这个切片进行修改,其对应的底层数组也会改变</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">darr := [...]<span class="keyword">int</span>&#123;<span class="number">57</span>, <span class="number">89</span>, <span class="number">90</span>, <span class="number">82</span>, <span class="number">100</span>, <span class="number">78</span>, <span class="number">67</span>, <span class="number">69</span>, <span class="number">59</span>&#125;</span><br><span class="line">dslice := darr[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Println(<span class="string">"array before"</span>,darr)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> dslice &#123;</span><br><span class="line">    dslice[i]++</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"array after"</span>,darr)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array before [<span class="number">57</span> <span class="number">89</span> <span class="number">90</span> <span class="number">82</span> <span class="number">100</span> <span class="number">78</span> <span class="number">67</span> <span class="number">69</span> <span class="number">59</span>]  </span><br><span class="line">array after [<span class="number">57</span> <span class="number">89</span> <span class="number">91</span> <span class="number">83</span> <span class="number">101</span> <span class="number">78</span> <span class="number">67</span> <span class="number">69</span> <span class="number">59</span>]</span><br></pre></td></tr></table></figure>

<p>先添加元素后再修改</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">darr := [...]<span class="keyword">int</span>&#123;<span class="number">57</span>, <span class="number">89</span>, <span class="number">90</span>, <span class="number">82</span>, <span class="number">100</span>, <span class="number">78</span>, <span class="number">67</span>, <span class="number">69</span>, <span class="number">59</span>&#125;</span><br><span class="line">dslice := darr[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Println(<span class="string">"array before"</span>,darr)</span><br><span class="line">dslice=<span class="built_in">append</span>(dslice, <span class="number">1000</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> dslice &#123;</span><br><span class="line">   dslice[i]++</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"array after"</span>,darr)</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array before [<span class="number">57</span> <span class="number">89</span> <span class="number">90</span> <span class="number">82</span> <span class="number">100</span> <span class="number">78</span> <span class="number">67</span> <span class="number">69</span> <span class="number">59</span>]</span><br><span class="line">array after [<span class="number">57</span> <span class="number">89</span> <span class="number">91</span> <span class="number">83</span> <span class="number">101</span> <span class="number">1001</span> <span class="number">67</span> <span class="number">69</span> <span class="number">59</span>]</span><br></pre></td></tr></table></figure>

<p>当多个片共享相同的底层数组时，每个元素所做的更改将在数组中反映出来。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">numa := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">78</span>, <span class="number">79</span> ,<span class="number">80</span>&#125;<span class="comment">//创建一个数组</span></span><br><span class="line">nums1 := numa[:] <span class="comment">//根据数组创建一个切片</span></span><br><span class="line">nums2 := numa[:]</span><br><span class="line">fmt.Println(<span class="string">"array before change 1"</span>,numa)</span><br><span class="line">nums1[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(<span class="string">"array after modification to slice nums1"</span>, numa)</span><br><span class="line">nums2[<span class="number">1</span>] = <span class="number">101</span></span><br><span class="line">fmt.Println(<span class="string">"array after modification to slice nums2"</span>, numa)</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array before change <span class="number">1</span> [<span class="number">78</span> <span class="number">79</span> <span class="number">80</span>]  </span><br><span class="line">array after modification to slice nums1 [<span class="number">100</span> <span class="number">79</span> <span class="number">80</span>]  </span><br><span class="line">array after modification to slice nums2 [<span class="number">100</span> <span class="number">101</span> <span class="number">80</span>]</span><br></pre></td></tr></table></figure>



<h3 id="切片的赋值拷贝"><a href="#切片的赋值拷贝" class="headerlink" title="切片的赋值拷贝"></a>切片的赋值拷贝</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>) <span class="comment">//[0 0 0]</span></span><br><span class="line">s2 := s1             <span class="comment">//将s1直接赋值给s2，s1和s2共用一个底层数组</span></span><br></pre></td></tr></table></figure>

<p>对一个切片的修改会影响另一个切片的内容，如果不想有该特性，可以使用内建的copy函数，具体可见下文</p>
<h3 id="切片的长度和容量"><a href="#切片的长度和容量" class="headerlink" title="切片的长度和容量"></a>切片的长度和容量</h3><p>切片的长度是切片中元素的数量。切片的容量是从创建切片的索引开始的底层数组中元素的数量。</p>
<h4 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h4><p>切片的长度可以通过内建函数 len() 函数来获取</p>
<h4 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h4><p>切片的容量可以通过内建函数 cap() 函数来获取</p>
<p>注意，切片的长度是可以随着切片的增删来改变的。切片的容量也不是固定的，当我们在向切片slice append添加数据的时候，Golang 会检查底层的数组的长度是否已经不够，如果长度不够，Golang 则会新建一个数组，把原数组的数据拷贝过去，再将 slice 中的指向数组的指针指向新的数组，也就是扩容，这时候容量cap也会随之改变。</p>
<h3 id="切片的遍历"><a href="#切片的遍历" class="headerlink" title="切片的遍历"></a>切片的遍历</h3><p>切片的遍历方式和数组是一致的，支持索引遍历和<code>for range</code>遍历。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">	fmt.Println(i, s[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> s &#123;</span><br><span class="line">	fmt.Println(index, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="空切片"><a href="#空切片" class="headerlink" title="空切片"></a>空切片</h3><p>一个切片在未初始化之前默认为 nil，长度为 0</p>
<p>要检查切片是否为空，请始终使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断。</p>
<h3 id="切片不能直接比较"><a href="#切片不能直接比较" class="headerlink" title="切片不能直接比较"></a>切片不能直接比较</h3><p>切片之间是不能比较的，我们不能使用<code>==</code>操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和<code>nil</code>比较。 一个<code>nil</code>值的切片并没有底层数组，一个<code>nil</code>值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是<code>nil</code>，例如下面的示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="keyword">int</span>         <span class="comment">//len(s1)=0;cap(s1)=0;s1==nil</span></span><br><span class="line">s2 := []<span class="keyword">int</span>&#123;&#125;        <span class="comment">//len(s2)=0;cap(s2)=0;s2!=nil</span></span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>) <span class="comment">//len(s3)=0;cap(s3)=0;s3!=nil</span></span><br></pre></td></tr></table></figure>

<p>所以要判断一个切片是否是空的，要是用<code>len(s) == 0</code>来判断，不应该使用<code>s == nil</code>来判断。</p>
<p>nil是指底层数组没有分配内存空间，len=0是指分配了空间但是没有填充数据元素。</p>
<h3 id="切片的添加和复制"><a href="#切片的添加和复制" class="headerlink" title="切片的添加和复制"></a>切片的添加和复制</h3><h4 id="append添加"><a href="#append添加" class="headerlink" title="append添加"></a>append添加</h4><p>Go语言的内建函数<code>append()</code>可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">1</span>)        <span class="comment">// [1]</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment">// [1 2 3 4]</span></span><br><span class="line">	s2 := []<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;  </span><br><span class="line">	s = <span class="built_in">append</span>(s, s2...)    <span class="comment">// [1 2 3 4 5 6 7]</span></span><br></pre></td></tr></table></figure>

<p>注意：通过var声明的零值切片可以在<code>append()</code>函数直接使用，无需初始化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h4 id="切片的扩容"><a href="#切片的扩容" class="headerlink" title="切片的扩容"></a>切片的扩容</h4><p>每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在<code>append()</code>函数调用时，所以我们通常都需要用原变量接收append函数的返回值。</p>
<p>关于切片扩容的具体详情可以看这里 <a href="https://h3l.github.io/posts/slice-append-grow-analyze/" target="_blank" rel="noopener">https://h3l.github.io/posts/slice-append-grow-analyze/</a></p>
<p>总结一下：slice 在 cap 长度小于 1024 之前容量是翻倍增长，在 cap 长度大于 1024 之后，因为存在着内存对齐，slice 的容量增长方式是最小增加 25%。</p>
<p>需要注意的是，切片扩容还会根据切片中元素的类型不同而做不同的处理，比如<code>int</code>和<code>string</code>类型的处理方式就不一样。</p>
<h4 id="copy复制"><a href="#copy复制" class="headerlink" title="copy复制"></a>copy复制</h4><p>在上文的 <a href="#切片的访问和修改">切片的访问和修改</a>  中提到过：当多个片共享相同的底层数组时，每个元素所做的更改将在数组中反映出来。</p>
<p>由于切片是引用类型，所以nums1和nums2其实都指向了同一块内存地址（数组numa）。修改nums2的同时nums1的值也会发生变化。</p>
<p>Go语言内建的<code>copy()</code>函数可以迅速地将一个切片的数据复制到另外一个切片空间中，<code>copy()</code>函数的使用格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span>(destSlice, srcSlice []T)</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>srcSlice: 数据来源切片</li>
<li>destSlice: 目标切片</li>
</ul>
<p>这样目标切片修改后源切片并不会受到影响</p>
<h3 id="切片的删除"><a href="#切片的删除" class="headerlink" title="切片的删除"></a>切片的删除</h3><p>go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从切片中删除元素</span></span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>&#125;</span><br><span class="line"><span class="comment">// 要删除索引为2的元素</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:<span class="number">2</span>], a[<span class="number">3</span>:]...)</span><br><span class="line">fmt.Println(a) <span class="comment">//[30 31 33 34 35 36 37]</span></span><br></pre></td></tr></table></figure>

<p>总结一下就是：要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Oxywen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://oxywen.github.io/post/go/7/">https://oxywen.github.io/post/go/7/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://oxywen.github.io">不闻星河须臾</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/note/">笔记</a><a class="post-meta__tags" href="/tags/go/">go</a></div><div class="social-share pull-right" data-disabled="facebook,google,twitter,diandian,linkedin"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="next-post pull-right"><a href="/post/go/6/"><span>Golang学习笔记-05数组</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/js/Valine1.3.10.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'EPD2p82uCKxOE9lfI7hiSp8e-gzGzoHsz',
  appKey:'Ycr0GVDd8SzCOTyaHEhGRf0s',
  placeholder:'评论时请留下您的昵称和邮箱，否则评论有关的消息可能无法及时通知给您',
  avatar:'identicon',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
});

$(document).ready(function(){ 
  if($("#vcomment").html()){
    var c_name = $('#vcomment input[name="nick"]');
    var c_mail = $('#vcomment input[type="email"]');
    var c_text = $('#veditor');
    var mailzz = /^([a-zA-Z0-9]+[_|\_|\.]?)*[a-zA-Z0-9]+@([a-zA-Z0-9]+[_|\_|\.]?)*[a-zA-Z0-9]+\.[a-zA-Z]{2,3}$/;
    var c_placeholder = c_text.attr('placeholder');
    $(".vcontrol .text-right button").hide();
    $(".vcontrol .text-right").prepend('<span class="submit_f vbtn">回复</span>');
    $('body').on('click','.submit_f',function(){
      if(nullpd(c_name.val()) || !mailzz.test(c_mail.val())){
        Tip("提交失败，昵称和邮箱不能为空或格式错误");
        return false;
      }
      if(!c_text.val()){
        Tip("提交失败，留言评论不能为空");
        return false;
      }
      $('.vsubmit').click();
    });
    function nullpd(str){
      if(str == "" || str == null || str == undefined){
        return true;
      }else{
        return false;
      }
    }
    function Tip(content){
      const str = `<div class="valert text-center"><div class="vtext">`+content+`</div></div>`;
      const vmark = document.querySelector('.vmark');
      vmark.innerHTML = str;
      vmark.style.display = 'block';
      setTimeout(function() {
        vmark.style.display = 'none';
        vmark.innerHTML = '';
      }, 1500);
    }
  }
}); </script></div></div><footer class="footer-bg" style="background-image: url(https://ww2.yunjiexi.club/2019/05/01/DZvIP.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By Oxywen</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>